<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数列分块入门2]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%95%B0%E5%88%97%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A82%2F</url>
    <content type="text"><![CDATA[题面 题目描述：给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，询问区间内小于某个值 $x$ 的元素个数。 思路：分块，我们维护每个块内的有序性，然后整块的二分查询。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxn = 5e4 + 10;int val[maxn],tag[maxn],n,pos[maxn],t;vector&lt;int&gt;f[1000];int L(int x)&#123;return (x - 1) * t + 1;&#125;int R(int x)&#123;return x * t;&#125;int read()&#123; int out = 0;bool flag = 0;char ch = getchar(); while(!isdigit(ch))&#123;flag = (ch == '-');ch = getchar();&#125; while(isdigit(ch))&#123;out = (out &lt;&lt; 1) + (out &lt;&lt; 3) + ch - '0';ch = getchar();&#125; return flag?-out:out;&#125;void reset(int x)&#123; f[x].clear(); for(int i = L(x) ; i &lt;= min(R(x),n) ; ++ i)f[x].push_back(val[i]); sort(f[x].begin(),f[x].end());&#125;void init()&#123; t = sqrt(n); for(int i = 1 ; i &lt;= n ; ++ i)pos[i] = (i - 1) / t + 1,f[pos[i]].push_back(val[i]); for(int i = 1 ; i &lt;= pos[n] ; ++ i)sort(f[i].begin(),f[i].end());&#125;void add(int l,int r,int c)&#123; for(int i = l ; i &lt;= min(R(pos[l]),r) ; ++ i) val[i] += c; reset(pos[l]); if(pos[l] != pos[r])&#123; for(int i = L(pos[r]) ; i &lt;= r ; ++ i) val[i] += c; reset(pos[r]); &#125; for(int i = pos[l] + 1 ; i &lt;= pos[r] - 1 ; ++ i) tag[i] += c;&#125;int ask(int l,int r,int w)&#123; int ans = 0; for(int i = l ; i &lt;= min(R(pos[l]),r) ; ++ i) if(val[i] + tag[pos[l]] &lt; w)ans++; if(pos[l] != pos[r])&#123; for(int i = L(pos[r]) ; i &lt;= r ; ++ i) if(val[i] + tag[pos[r]] &lt; w)ans++; &#125; for(int i = pos[l] + 1 ; i &lt;= pos[r] - 1 ; ++ i) &#123; int z = w - tag[i]; ans += lower_bound(f[i].begin(),f[i].end(),z) - f[i].begin(); &#125; return ans;&#125;signed main()&#123; n = read(); for(int i = 1 ; i &lt;= n ; ++ i)val[i] = read(); init(); for(int i = 1 ; i &lt;= n ; ++ i) &#123; int opt,l,r,c; opt = read();l = read();r = read();c = read(); if(opt == 0)add(l,r,c); else printf("%lld\n",ask(l,r,c * c));//cout &lt;&lt; ask(l,r,c * c) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qtree1]]></title>
    <url>%2F2019%2F03%2F06%2FQtree1%2F</url>
    <content type="text"><![CDATA[题面 思路：很裸的一道树剖题，我们把边权化为点权就可以了。注意不要加上两点的LCA。当我们两个点跳到同一条链上时，深度更浅的点就是两点的LCA了。我们只需查询区间$[id[x]+1,id[y]]$就可以了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;#define int long longint size[maxn],son[maxn],n,head[maxn],tot,top[maxn],fa[maxn],dep[maxn];int cnt,id[maxn],a[maxn],val[maxn];struct node&#123; int maxx;&#125;tr[maxn &lt;&lt; 2];struct edge&#123; int next,to,w;&#125;e[maxn &lt;&lt; 1];void add(int u,int v,int w)&#123; e[++tot] = (edge)&#123;head[u],v,w&#125;; head[u] = tot;&#125;void dfs1(int x,int f)&#123; dep[x] = dep[f] + 1; size[x] = 1;fa[x] = f; int maxson = -1; for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(v == f)continue; val[v] = e[i].w; dfs1(v,x); size[x] += size[v]; if(size[v] &gt; maxson)son[x] = v,maxson = size[v]; &#125;&#125;void dfs2(int x,int topf)&#123; top[x] = topf;id[x] = ++cnt; a[cnt] = val[x]; if(!son[x])return; dfs2(son[x],topf); for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(v == fa[x] or v == son[x])continue; dfs2(v,v); &#125;&#125;void build(int root,int l,int r)&#123; if(l == r)&#123; tr[root].maxx = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(root &lt;&lt; 1,l,mid); build(root &lt;&lt; 1 | 1,mid + 1,r); tr[root].maxx = max(tr[root &lt;&lt; 1].maxx,tr[root &lt;&lt; 1 | 1].maxx);&#125;void change(int root,int l,int r,int x,int b)&#123; if(l == x and r == x)&#123; tr[root].maxx = b; return; &#125; int mid = l + r &gt;&gt; 1; if(x &lt;= mid)change(root &lt;&lt; 1,l,mid,x,b); if(x &gt; mid)change(root &lt;&lt; 1 | 1,mid + 1,r,x,b); tr[root].maxx = max(tr[root &lt;&lt; 1].maxx,tr[root &lt;&lt; 1 | 1].maxx);&#125;int query(int root,int l,int r,int L,int R)&#123; int ans = 0; if(l &gt;= L and r &lt;= R)return tr[root].maxx; int mid = l + r &gt;&gt; 1; if(L &lt;= mid)ans = max(ans,query(root &lt;&lt; 1,l,mid,L,R)); if(R &gt; mid)ans = max(ans,query(root &lt;&lt; 1 | 1,mid + 1,r,L,R)); return ans;&#125;int road_ask(int x,int y)&#123; int ans = 0; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]])swap(x,y); ans = max(ans,query(1,1,n,id[top[x]],id[x])); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y])swap(x,y); ans = max(ans,query(1,1,n,id[x] + 1,id[y])); return ans;&#125;signed main()&#123; cin &gt;&gt; n; for(int i = 1,u,v,w ; i &lt; n ; ++ i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u,v,w);add(v,u,w); &#125; dfs1(1,0); dfs2(1,1); build(1,1,n); string opt; while(cin &gt;&gt; opt) &#123; if(opt == "DONE")break; int a,b,x; cin &gt;&gt; a &gt;&gt; b; if(opt == "CHANGE")&#123; int v = e[a * 2 - 1].to,u = e[a * 2].to; if(dep[v] &gt; dep[u])x = v; else x = u; change(1,1,n,id[x],b); &#125; if(opt == "QUERY") &#123; if(a == b)&#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; cout &lt;&lt; road_ask(a,b) &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO18DEC-Fine_Dining]]></title>
    <url>%2F2019%2F03%2F05%2FUSACO18DEC-Fine-Dining%2F</url>
    <content type="text"><![CDATA[题面 思路：我们先考虑暴力，我们可以先按题意模拟先从N点跑一次最短路，然后我们在从每个草垛跑一次最短路，时间复杂度$O(kn)$，得到$70$分的好成绩。我们再考虑优化，我们发现我们从每个草垛跑最短路时跑了许多冗余状态。我们可以考虑在图上动手脚，我们将图进行分层，我们先在原图上跑一遍SPFA，然后再将图复制一份，从第一个图的干草跺向第二图的相同节点连一条-w的有向边。最后比较两次的dis值即可 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e5 + 10;const int maxn = 1e5 + 10;int dis[maxn],dist[maxn],n,m,k,head[maxn],tot;bool vis[maxn];struct edge&#123; int next,to,w;&#125;e[maxm &lt;&lt; 2];void add(int u,int v,int w)&#123; e[++tot] = (edge)&#123;head[u],v,w&#125;; head[u] = tot;&#125;void spfa(int st)&#123; memset(dis,0x3f,sizeof(dis)); queue&lt;int&gt;q; q.push(st);vis[st] = 1;dis[st] = 0; while(q.size()) &#123; int x = q.front();q.pop();vis[x] = 0; for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(dis[v] &gt; dis[x] + e[i].w)&#123; dis[v] = dis[x] + e[i].w; if(!vis[v])&#123; vis[v] = 1; q.push(v); &#125; &#125; &#125; &#125;&#125;void spfa2(int st)&#123; memset(dist,0x3f,sizeof(dist)); queue&lt;int&gt;q; vis[st] = 1; q.push(st); dist[st] = 0; while(q.size()) &#123; int x = q.front();q.pop(); for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(dist[v] &gt; dist[x] + e[i].w)&#123; dist[v] = dist[x] + e[i].w; if(!vis[v])&#123; dist[v] = dist[x] + e[i].w; q.push(v); &#125; &#125; &#125; &#125;&#125;signed main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1,u,v,w ; i &lt;= m ; ++ i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u,v,w);add(v,u,w); add(u + n,v + n,w);add(v + n,u + n,w); &#125; spfa(n); for(int i = 1,x,y ; i &lt;= k ; ++ i) &#123; cin &gt;&gt; x &gt;&gt; y; add(x,x + n,-y); &#125; spfa2(n); for(int i = 1 ; i &lt; n ; ++ i) &#123; if(dis[i] &gt;= dist[i + n])cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO18DEC]Cowpatibility]]></title>
    <url>%2F2019%2F03%2F05%2FUSACO18DEC-Cowpatibility%2F</url>
    <content type="text"><![CDATA[题面 思路：正解做法：考虑容斥。不能和谐的奶牛的对数等于总对数-和谐的奶牛数。我们可以统计出与当前的奶牛口味有1个相同的奶牛数，有2个相同的……根据容斥，奇数加，偶数减。我们就可以在$O(2^5N)$的时间复杂度内完成了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define re registerconst int maxn = 5e4 + 10;inline long long read()&#123; long long out = 0;bool flag = 0;char ch = getchar(); while(!isdigit(ch))&#123;flag = (ch == '-');ch = getchar();&#125; while(isdigit(ch))&#123;out = (out &lt;&lt; 1) + (out &lt;&lt; 3) + ch - '0';ch = getchar();&#125; return flag?-out:out;&#125;struct ice&#123; int x[6]; ice()&#123;x[1] = x[2] = x[3] = x[4] = x[5] = -1;&#125;//构造函数，此处需赋值为-1，因为我们是按照^来比较大小的，不能赋值为0；&#125;a[maxn];inline bool operator &lt; (const ice &amp;q,const ice &amp;p)&#123;//重载&lt;号比较大小 for(int i = 1 ; i &lt;= 5 ; ++ i) if(q.x[i] ^ p.x[i])return q.x[i] &lt; p.x[i]; return false;&#125;map&lt;ice,long long&gt;mp;//用mp存某个方案有多少个奶牛long long n,ans;signed main()&#123; n = read(); ans = n * (n - 1) / 2; for(re int i = 1 ; i &lt;= n ; ++ i) for(re int j = 1 ; j &lt;= 5 ; ++ j) a[i].x[j] = read(); for(re int i = 1 ; i &lt;= n ; ++ i) &#123; sort(a[i].x + 1,a[i].x + 6);//排序方便比较 for(re int j = 1,top ; j &lt; (1 &lt;&lt; 5) ; ++ j)//枚举子集 &#123; ice tmp; top = 0; for(re int k = 0;k &lt; 5;++ k)if(j &amp; (1&lt;&lt;k))tmp.x[++top]=a[i].x[k+1]; ans -= (top&amp;1?1:-1) * mp[tmp];//容斥 ++ mp[tmp]; &#125; &#125; printf("%lld\n",ans); return 0;&#125; 但是由于这个做法比较的常数比较大，所以会跑的特别慢。以下介绍一种暴力但是常数特别小的做法。 暴力做法我们用一个$map&lt;int,bitset &gt;$记录当前的数有哪些奶牛有。然后用$bitset$优化，就可以过了，时间复杂度是$O(n^2)$的。但是$bitset$优化了很大的常数，并且位运算特快。所以比正解快了一倍 代码：12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e4 + 10;map&lt;int,bitset&lt;maxn&gt; &gt;mp;int n,a[maxn][10],ans;signed main()&#123; cin &gt;&gt; n; for(int i = 1 ; i &lt;= n ; ++ i) &#123; for(int j = 1 ; j &lt;= 5 ; ++ j) &#123; cin &gt;&gt; a[i][j]; mp[a[i][j]].set(i);//将第i位数字置为1 &#125; &#125; for(int i = 1 ; i &lt;= n ; ++ i) &#123; bitset&lt;maxn&gt;q; for(int j = 1 ; j &lt;= 5 ; ++ j)q |= mp[a[i][j]];//统计有哪些奶牛有这种口味 ans += n - q.count(); &#125; cout &lt;&lt; ans / 2 &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO18DEC]Teamwork]]></title>
    <url>%2F2019%2F03%2F03%2FUSACO18DEC-Teamwork%2F</url>
    <content type="text"><![CDATA[题面一个简单的dp 思路：我们设dp[i][j]表示我们考虑到了第i个数，最后一个块的大小为j，我们有两种决策：1.我们把第i个数独立，即$dp[i][1]$会由$dp[i-1]j$转移过来。 2.我们把第i个数加入前一个块，即$dp[i][j]$会由$dp[i-1][j-1]$转移过来。 那么怎么算贡献呢？我们可以考虑记上一个数组$maxx[i][j]$表示最后一个块大小为$j$时块内最大的数。更新时先减去原先的最大的数乘以块的大小，再加上新的最大值乘以新的块的大小。由于每个决策点都只与前一个决策点有关我们可以考虑滚动数组优化一维空间，(我只优化了$maxx$数组)读者可优化$dp$数组。 代码：123456789101112131415161718192021222324252627// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxn = 1e4 + 10;const int maxk = 1e3 + 10;int dp[maxn][maxk],maxx[2][maxk],a[maxn],ans,n,k;//dp表示当前决策点以及最后一个块的大小,maxx为最后一个块内的最大值signed main()&#123; cin &gt;&gt; n &gt;&gt; k; for(int i = 1 ; i &lt;= n ; ++ i)cin &gt;&gt; a[i]; for(int i = 1 ; i &lt;= n ; ++ i) &#123; for(int j = 1 ; j &lt;= min(i,k) ; ++ j) dp[i][1] = max(dp[i][1],dp[i - 1][j] + a[i]);//由上一个状态转移 maxx[i&amp;1][1] = a[i]; for(int j = 1 ; j &lt; min(i,k) ; ++ j) &#123; maxx[i&amp;1][j + 1] = max(maxx[(i - 1)&amp;1][j],a[i]); dp[i][j + 1] = dp[i - 1][j] - maxx[(i - 1)&amp;1][j] * j + maxx[i&amp;1][j + 1] * (j + 1);//把i并到它上一个中。 &#125; &#125; for(int i = 1 ; i &lt;= k ; ++ i) ans = max(ans,dp[n][i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划,动规,dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件包管理器]]></title>
    <url>%2F2019%2F03%2F02%2F%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题面思路：依赖关系不存在环，说明这是一颗有向树，0为根节点(不依赖任何的软件包)。安装时是查询x到根路径上权值为0的节点个数，然后再将x到根路径上的节点权值全部变为1就行了。卸载时查询x的子树中有多少个权值为1的节点个数，然后再将x及其子树的所有节点全部变为0就行了。上述操作只需用树链剖分实现，把线段树改为01可区间修改的线段树就可以了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// luogu-judger-enable-o2//原谅我不可饶恕的常数#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;int n,fa[maxn],size[maxn],son[maxn],id[maxn],dep[maxn],top[maxn],cnt,q;vector&lt;int&gt;e[maxn];struct node&#123; int val,tag;&#125;tr[maxn &lt;&lt; 2];void dfs1(int x)&#123; dep[x] = dep[fa[x]] + 1; size[x] = 1;int maxson = -1; for(int i = 0 ; i &lt; e[x].size() ; ++ i) &#123; int v = e[x][i]; fa[v] = x; dfs1(v); size[x] += size[v]; if(size[v] &gt; maxson)maxson = size[v],son[x] = v; &#125;&#125;void dfs2(int x,int topf)&#123; top[x] = topf; id[x] = ++cnt; if(!son[x])return; dfs2(son[x],topf); for(int i = 0 ; i &lt; e[x].size() ; ++ i) &#123; int v = e[x][i]; if(v == son[x])continue; dfs2(v,v); &#125;&#125;void update(int root)&#123; tr[root].val = (tr[root &lt;&lt; 1].val + tr[root &lt;&lt; 1 | 1].val);&#125;void build(int root,int l,int r)&#123; tr[root].tag = -1; if(l == r)return; int mid = l + r &gt;&gt; 1; build(root &lt;&lt; 1,l,mid); build(root &lt;&lt; 1 | 1,mid + 1,r);&#125;void push_down(int root,int l,int r)&#123; if(tr[root].tag == 0)&#123; tr[root &lt;&lt; 1].val = 0; tr[root &lt;&lt; 1].tag = 0; tr[root &lt;&lt; 1 | 1].val = 0; tr[root &lt;&lt; 1 | 1].tag = 0; &#125; if(tr[root].tag == 1)&#123; int mid = l + r &gt;&gt; 1; tr[root &lt;&lt; 1].val = mid - l + 1; tr[root &lt;&lt; 1].tag = 1; tr[root &lt;&lt; 1 | 1].val = r - mid; tr[root &lt;&lt; 1 | 1].tag = 1; &#125; tr[root].tag = -1;&#125;int query0(int root,int l,int r,int L,int R)&#123; int ans = 0; if(l &gt;= L and r &lt;= R)return r - l + 1 - tr[root].val; int mid = l + r &gt;&gt; 1; push_down(root,l,r); if(L &lt;= mid)ans += query0(root &lt;&lt; 1,l,mid,L,R); if(R &gt; mid)ans += query0(root &lt;&lt; 1 | 1,mid + 1,r,L,R); update(root); return ans;&#125;int query1(int root,int l,int r,int L,int R)&#123; int ans = 0; if(l &gt;= L and r &lt;= R)return tr[root].val; int mid = l + r &gt;&gt; 1; push_down(root,l,r); if(L &lt;= mid)ans += query1(root &lt;&lt; 1,l,mid,L,R); if(R &gt; mid)ans += query1(root &lt;&lt; 1 | 1,mid + 1,r,L,R); update(root); return ans;&#125;void change(int root,int l,int r,int L,int R,int opt)&#123; if(l &gt;= L and r &lt;= R)&#123; if(opt == 0) &#123; tr[root].val = 0; tr[root].tag = 0; &#125; if(opt == 1) &#123; tr[root].val = r - l + 1; tr[root].tag = 1; &#125; return; &#125; int mid = l + r &gt;&gt; 1; push_down(root,l,r); if(L &lt;= mid)change(root &lt;&lt; 1,l,mid,L,R,opt); if(R &gt; mid)change(root &lt;&lt; 1 | 1,mid + 1,r,L,R,opt); update(root);&#125;int road_ask(int x)&#123; int ans = 0; while(top[x] != top[0]) &#123; ans += query0(1,1,n,id[top[x]],id[x]); x = fa[top[x]]; &#125; ans += query0(1,1,n,id[0],id[x]); return ans;&#125;void Install(int x)&#123; while(top[x] != top[0]) &#123; change(1,1,n,id[top[x]],id[x],1); x = fa[top[x]]; &#125; change(1,1,n,id[0],id[x],1);&#125;int son_ask(int x)&#123; return query1(1,1,n,id[x],id[x] + size[x] - 1);&#125;void Uninstall(int x)&#123; change(1,1,n,id[x],id[x] + size[x] - 1,0);&#125;signed main()&#123; cin &gt;&gt; n; for(int i = 1,x ; i &lt; n ; ++ i) &#123; cin &gt;&gt; x; e[x].push_back(i); &#125; dfs1(0); dfs2(0,0); build(1,1,n); cin &gt;&gt; q; while(q--) &#123; string opt;int x; cin &gt;&gt; opt &gt;&gt; x; if(opt == "install")cout &lt;&lt; road_ask(x) &lt;&lt; endl,Install(x); else cout &lt;&lt; son_ask(x) &lt;&lt; endl,Uninstall(x); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的统计]]></title>
    <url>%2F2019%2F03%2F02%2F%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[题面思路：树链剖分模板题，1操作直接修改，2把线段树维护信息加上区间最大值 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxn = 3e4 + 10;const int inf = 1 &lt;&lt; 30;int n,head[maxn],tot,dep[maxn],fa[maxn],son[maxn],a[maxn],top[maxn],cnt;int id[maxn],size[maxn],m,w[maxn];struct edge&#123; int next,to;&#125;e[maxn &lt;&lt; 1];struct node&#123; int val,maxx;&#125;tr[maxn &lt;&lt; 2];void add(int u,int v)&#123; e[++tot] = (edge)&#123;head[u],v&#125;; head[u] = tot;&#125;void dfs1(int x,int f,int deep)&#123; dep[x] = deep; fa[x] = f; size[x] = 1; int maxson = -1; for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(v == f)continue; dfs1(v,x,deep + 1); size[x] += size[v]; if(size[v] &gt; maxson)son[x] = v,maxson = size[v]; &#125;&#125;void dfs2(int x,int topf)&#123; id[x] = ++ cnt; a[cnt] = w[x]; top[x] = topf; if(!son[x])return; dfs2(son[x],topf); for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(v == fa[x] or v == son[x])continue; dfs2(v,v); &#125;&#125;void update(int root)&#123; tr[root].val = (tr[root &lt;&lt; 1].val + tr[root &lt;&lt; 1 | 1].val); tr[root].maxx = max(tr[root &lt;&lt; 1].maxx,tr[root &lt;&lt; 1 | 1].maxx);&#125;void build(int root,int l,int r)&#123; if(l == r)&#123; tr[root].val = a[l]; tr[root].maxx = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(root &lt;&lt; 1,l,mid); build(root &lt;&lt; 1 | 1,mid + 1,r); update(root);&#125;int query_max(int root,int l,int r,int L,int R)&#123; int ans = -inf; if(l &gt;= L and r &lt;= R)return tr[root].maxx; int mid = l + r &gt;&gt; 1; if(L &lt;= mid)ans = max(ans,query_max(root &lt;&lt; 1,l,mid,L,R)); if(R &gt; mid)ans = max(ans,query_max(root &lt;&lt; 1 | 1,mid + 1,r,L,R)); return ans;&#125;int query_sum(int root,int l,int r,int L,int R)&#123; int ans = 0; if(l &gt;= L and r &lt;= R)return tr[root].val; int mid = l + r &gt;&gt; 1; if(L &lt;= mid)ans += query_sum(root &lt;&lt; 1,l,mid,L,R); if(R &gt; mid)ans += query_sum(root &lt;&lt; 1 | 1,mid + 1,r,L,R); return ans;&#125;int qmax(int x,int y)&#123; int ans = -inf; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]])swap(x,y); ans = max(ans,query_max(1,1,n,id[top[x]],id[x])); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y])swap(x,y); ans = max(ans,query_max(1,1,n,id[x],id[y])); return ans;&#125;int qsum(int x,int y)&#123; int ans = 0; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]])swap(x,y); ans += query_sum(1,1,n,id[top[x]],id[x]); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y])swap(x,y); ans += query_sum(1,1,n,id[x],id[y]); return ans;&#125;void change(int root,int l,int r,int x,int y)&#123; if(l == x and r == x)&#123; tr[root].val = y; tr[root].maxx = y; return; &#125; int mid = l + r &gt;&gt; 1; if(x &lt;= mid)change(root &lt;&lt; 1,l,mid,x,y); if(x &gt; mid)change(root &lt;&lt; 1 | 1,mid + 1,r,x,y); update(root);&#125;signed main()&#123; cin &gt;&gt; n; for(int i = 1,u,v ; i &lt; n ; ++ i) &#123; cin &gt;&gt; u &gt;&gt; v; add(u,v);add(v,u);//加边 &#125; for(int i = 1 ; i &lt;= n ; ++ i)cin &gt;&gt; w[i]; dfs1(1,0,1); dfs2(1,1); build(1,1,n); cin &gt;&gt; m; while(m--) &#123; string opt;int x,y; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; if(opt == "CHANGE")change(1,1,n,id[x],y); if(opt == "QMAX")cout &lt;&lt; qmax(x,y) &lt;&lt; endl; if(opt == "QSUM")cout &lt;&lt; qsum(x,y) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCT]]></title>
    <url>%2F2019%2F03%2F02%2FLCT%2F</url>
    <content type="text"><![CDATA[题面 LCT板子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxn = 3e5 + 10;int n,m,v[maxn],s[maxn],sum[maxn],fa[maxn],son[maxn][2],tag[maxn];bool check(int x)&#123; return (son[fa[x]][0] == x or son[fa[x]][1] == x);&#125;void update(int x)&#123; sum[x] = sum[son[x][0]] ^ sum[son[x][1]] ^ v[x];&#125;void rev(int x)&#123; swap(son[x][0],son[x][1]); tag[x] ^= 1;&#125;void push_down(int x)&#123; if(tag[x])&#123; if(son[x][0])rev(son[x][0]); if(son[x][1])rev(son[x][1]); tag[x] = 0; &#125;&#125;void rotate(int x)&#123; int y = fa[x],z = fa[y],dir = son[y][1] == x;int opp = son[x][!dir];//与x处于相反位置的x的儿子 if(check(y))son[z][son[z][1] == y] = x;//把x顶替y的儿子位置 son[x][!dir] = y;//把x的反儿子置为y son[y][dir] = opp;//把x原来的的位置变为它儿子 if(opp)fa[opp] = y; fa[y] = x; fa[x] = z; update(y);&#125;void splay(int x)&#123; int y = x,top = 0,z; s[++top] = y; while(check(y))//因为要先把上面的标记放完。 &#123; y = fa[y]; s[++top] = y; &#125; while(top)push_down(s[top--]); while(check(x)) &#123; y = fa[x];z = fa[y];//y是父亲，z是祖父。 if(check(y))rotate((son[y][0] == x) ^ (son[z][0] == y) ? x : y);//如果y还不是根节点，就说明还可以旋 rotate(x);//无论怎么旋，最后都要旋x。 &#125; update(x);&#125;void access(int x)//打通路径&#123; for(int y = 0 ; x ; x = fa[y = x]) splay(x),son[x][1] = y,update(x);//先把x在其辅助树的位置变为根，再连虚边所指的父亲节点； //此处须注意，因为我们最开始y为0，所以最开始把x旋到它在的辅助树的根时，我们设其右子树为0；&#125;void make_root(int x)&#123; access(x);splay(x);//先把x到根的路径打通，再把x在辅助树中splay为根 rev(x);//把整颗树翻转，即换根改深度。&#125;void road(int x,int y)&#123; make_root(x);//把x置为根 access(y);splay(y);//把y到x的路径打通&#125;int find_root(int x)&#123; access(x);splay(x);//把x旋到根后，最左边的节点就是根了 while(son[x][0])push_down(x),x = son[x][0];//一路往左。 splay(x);//再把原根旋回去 return x;&#125;void link(int x,int y)&#123; make_root(x); if(find_root(y) != x)fa[x] = y;&#125;void cut(int x,int y)&#123; make_root(x); if(find_root(y) == x and fa[y] == x and !son[y][0])&#123; fa[y] = son[x][1] = 0; update(x); &#125;&#125;signed main()&#123; ios::sync_with_stdio(0);// freopen("stdP3690.in","r",stdin);// freopen("stdP3690.out","w",stdout); cin &gt;&gt; n &gt;&gt; m; for(int i = 1 ; i &lt;= n ; ++ i)cin &gt;&gt; v[i]; while(m--) &#123; int opt,x,y; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; if(opt == 0)&#123; road(x,y); cout &lt;&lt; sum[y] &lt;&lt; endl; &#125; if(opt == 1)link(x,y); if(opt == 2)cut(x,y); if(opt == 3)splay(x),v[x] = y; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[食物]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%A3%9F%E7%89%A9%2F</url>
    <content type="text"><![CDATA[评测 2019.01.272.食物问题描述：辉夜本来是生活在月宫的月之公主。 辉夜从月都弄了很多吃的回到了幻想乡，有$n$中不同的食物，第$i$中食物的美味度为$t_i$，一份食物的大小为$u_i$，共有$v_i$份。但是麻烦的事情出现了，她有把这些食物运回永和亭，于是辉夜便弄来了$m$种运载工具。第$i$种运载工具可以运输大小总和不超过$x_i$的食物，运输一次的费用是$y_i$，总共可以运输$z_i$次。辉夜打算选取一些食物运回永和亭，他们的美味度之和（每份食物的和，即使他们都是同一种食物）至少是$p$。值得注意的是，一份食物可以被拆成几份分批次运输，达到永和亭后在组装起来。但是如果不把一份食物完整的运过去，是无法得到美味度的。辉夜想知道最少需要花费的运输费用是多少。由于辉夜的预算仅有$50000$，因此如果费用超过这个数或者无法获得$p$的的美味度，输出”TAT”。$1\leq n,m \le200,0\leq p \le 50000,1\leq t_i,u_i,v_i,x_i,y_i,z_i\le100$ 输入格式第一行一个数$test$，表示有$test$组数据。对于每组数据，第一行有三个数$n,m,p$。 接下来$n$行，每行三个整数$t,u,v$，描述一种食物。 最后m行，每行三个整数$x,y,z$，描述一种运载工具。 输出格式对于每组数据，输出辉夜想知道的答案。注意存在误解的情况。 样例输入4 1 1 7 14 2 1 1 2 2 1 1 10 10 10 1 5 7 2 5 3 34 1 4 1 9 4 2 5 3 3 1 3 3 5 3 2 3 4 5 6 7 5 5 3 8 1 1 1 1 2 1 1 1 1 样例输出4 14 12 TAT 数据规模与约定test不会太大。 对于前20%的数据，$n,m\leq20$。 对于前50%的数据，$n,m\leq30,t_i,u_i,v_i,x_i,y_i,z_i\leq10$。 思路：双重的多重背包，第一次我们把运输量作为背包容量，美味度为收益。求出运输$p$的美味度所需的最小运输量，第二次我们把钱作为背包容量，运输量作为收益。求出运输最小运输量的最小费用。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e5 + 10;const int maxnn = 6e5 + 10;int n,m,p,dp1[maxnn],need,dp2[maxn],tot1,tot2;bool flag;struct food&#123; int t,u;&#125;f[maxn];struct tool&#123; int x,y;&#125;t[maxn];int main()&#123;// freopen("B.in","r",stdin);// freopen("B.out","w",stdout); ios::sync_with_stdio(0); int T; cin &gt;&gt; T; while(T--) &#123; flag = 0; need = 1e9 + 10;memset(dp1,0,sizeof(dp1));memset(dp2,0,sizeof(dp2)); tot1 = 0;tot2 = 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for(int i = 1 ; i &lt;= n ; ++ i) &#123; int t,u,v; cin &gt;&gt; t &gt;&gt; u &gt;&gt; v; int k = 1; while(v &gt;= k) &#123; f[++tot1].u = u * k; f[tot1].t = t * k; v -= k; k &lt;&lt;= 1; &#125; f[++tot1].u = v * u;f[tot1].t = t * v;//二进制拆分 &#125; for(int i = 1 ; i &lt;= tot1 ; ++ i) for(int j = 50000 ; j &gt;= f[i].u ; -- j)//f[i].u * f[i].v ; -- j) &#123; dp1[j] = max(dp1[j],dp1[j - f[i].u] + f[i].t);//求出用j的运输量可以运输的最大美味度 if(dp1[j] &gt;= p)need = min(need,j);//如果当前的美味度比需要的大了，就将当前的运输量与最小运输量比较 &#125;// cout &lt;&lt; need &lt;&lt; endl;我们就求出了最小运输量了。 for(int i = 1 ; i &lt;= m ; ++ i) &#123; int k = 1,x,y,z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; while(z &gt;= k) &#123; t[++tot2].x = x * k; t[tot2].y = y * k; z -= k; k &lt;&lt;= 1; &#125; t[++tot2].x = x * z;t[tot2].y = y * z;//二进制拆分 &#125; /*if(need == 1e9 + 10)&#123; cout &lt;&lt; "TAT" &lt;&lt; endl; continue; &#125;*/ int ans = 50000; for(int i = 1 ; i &lt;= tot2 ; ++ i) for(int j = 50000 ; j &gt;= t[i].y ; -- j) &#123; dp2[j] = max(dp2[j],dp2[j - t[i].y] + t[i].x);//求出用j的费用可以运输的最大量 if(dp2[j] &gt;= need)ans = min(ans,j);//如果当前的运输量比至少运输量大，就将当前的费用与最小费用比较。 &#125; if(ans == 50000)cout &lt;&lt; "TAT" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划,动规,dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旅游]]></title>
    <url>%2F2019%2F03%2F02%2F%E6%97%85%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[评测 2019.01.271.旅游问题描述：辉夜本来是生活在月宫的月之公主。 辉夜很想出去走走，就算不去那些引人入胜的景点也没有什么关系，只是看着路边变化不断的风景，辉夜就很开心了。但是辉夜讨厌太拥挤的地方，她会拒绝一些人气旺盛的道路。幻想乡有n个景点（从1开始标号），有m条双向的道路连在景点之间，每条道路有一个人气值d，表示这条道路的拥挤程度。辉夜不会经过那些人气值大于 x的道路，她想知道有多少对景点(a，b)满足她能够从景点a到达景点b。 输入格式第一行一个数test，表示有test组数据。对于每组数据，第一行有三个数n,m,q,q表示有q个询问。接下来m行，每行三个数x,y,d，表示有一条连接x,y人气值为d的道路。最后q行，每行一个询问x。 输出格式对于每组数据，你需要输出q行，依次回答所有询问。 样例输入1234567891015 5 32 3 63341 5 157243 5 57054 3 123821 3 2172660001000013000 样例输出1232612 数据规模于约定test不会太大。对于前10%的数据，n&lt;=200。对于前40%的数据，n&lt;=500，m&lt;=2000，q&lt;=100，d&lt;=1000。对于前100%的数据，q&lt;=5000。 思路：考虑暴力做法，我们可以在每次询问时暴力模拟，期望得分$40pts$。 其实仔细想想我们暴力模拟时，无非就是一个找联通块的过程。等等，联通块，你想到了什么。并查集，但是在实际应用中并查集并没有优化，我们在仔细思考，有什么并查集比暴力更优秀的地方，于是我们想到了离线做法，先将边按边权排序，再将询问排序每次加边时考虑一下对联通块的贡献，就可已在$O((m + q)logq)$并查集可以用路径压缩，这样就可以忽略前面的常数了。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#pragma GCC optimize(2)using namespace std;inline int read() &#123; int res = 0 , flag = 1; char ch = getchar(); while(!isdigit(ch)) &#123; if(ch == '-') flag = -1; ch = getchar(); &#125; while(isdigit(ch)) &#123; res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + ch - '0'; ch = getchar(); &#125; return res * flag;&#125;const int N=2e6;const int M=1e6;const int Q=5e6;const int D=1e6;int n,m,q,fa[N+5],size[N+5],answer[Q+5];struct Edge&#123; int begin; int end; int val;&#125;edge[M+5];struct Query&#123; int id; int limit;&#125;query[Q+5];inline bool comp_edge(Edge x,Edge y) &#123; return x.val &lt; y.val;&#125;inline bool comp_query(Query x,Query y) &#123; return x.limit &lt; y.limit;&#125;inline int find(int x) &#123; if(fa[x] == x) return x; return fa[x] = find(fa[x]);&#125;int main() &#123;// freopen("A.in","r",stdin);// freopen("A.out","w",stdout); int test = read(); while(test -- ) &#123; n = read(); m = read(); q = read(); for(register int i = 1 ; i &lt;= n ; ++ i) fa[i] = i; for(register int i = 1 ; i &lt;= n ; ++ i) size[i] = 1; for(register int i = 1 ; i &lt;= m ; ++ i) &#123; edge[i].begin = read(); edge[i].end = read(); edge[i].val = read(); &#125; for(register int i = 1 ; i &lt;= q ; ++ i) query[i].limit = read() , query[i].id = i; sort(edge+1,edge+1+m,comp_edge); sort(query+1,query+1+q,comp_query); int j = 1 , ans = 0; for(register int i = 1 ; i &lt;= q ; ++ i) &#123; //此处优化的原理,采用离线做法充分利用答案的单调性 while(j &lt;= m and edge[j].val &lt;= query[i].limit) &#123; int a = edge[j].begin , b = edge[j].end; if(find(a) != find(b)) &#123; ans -= size[find(a)] * (size[find(a)] - 1); ans -= size[find(b)] * (size[find(b)] - 1); size[find(a)] += size[find(b)]; fa[find(b)] = fa[find(a)]; ans += size[find(a)] * (size[find(a)] - 1); &#125; j++; &#125; answer[query[i].id] = ans; &#125; for(register int i = 1 ; i &lt;= q ; ++ i) printf("%d\n",answer[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDQ分治]]></title>
    <url>%2F2019%2F01%2F14%2FCDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[CDQ分治定义：什么是CDQ分治呢。CDQ分治是雅礼的一名IOI金牌选手陈丹琦提出来的一种用分治的思想解决一类与维护决策有关的问题。现多用于求解偏序问题。 下面是她的原文：分治的基本思想是将一个规模为$N$的问题分解为$K$个规模较小的子问题，这些子问题互相独立且与原问题性质相同。求出子问题的接，就可得到原问题的接。分治算法非常基础，但是却非常重要，本文将从今年$NOI$的一道动态规划$Cash$开始谈如何利用分治思想来解决一类与维护决策有关的问题。（具体请看陈丹琦论文） 主要思想：用sort解决第一维，再用$N-2$层CDQ分治解决中间的$N-2$维，最后一维用树状数组实现。 你可能看到这还有一点不理解，我们以一下的题目为例，来具体讲解CDQ分治的用途以及如何实现。 二维偏序： 数星星 题面：loj，poj 二维的问题十分简单，因为$y$已经有序了所以我们可以考虑用树状数组来解决这题。我们可以维护一个树状数组按先后顺序依次插入元素，再查询当前的元素前面有多少个数。然后将答案存入一个数组，我们就可以写这题了。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e4 + 10;int n,ans[maxn],tree[maxn * 10];struct node&#123; int x; int y;&#125;a[maxn];void update(int x,int y)&#123; for(int i = x ; i &lt;= maxn * 2 ; i += (i &amp; (-i))) tree[i] += y;&#125;int sum(int x)&#123; int res = 0; for(int i = x ; i ; i -= (i &amp; (-i))) res += tree[i]; return res;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1 ; i &lt;= n ; ++ i) cin &gt;&gt; a[i].x &gt;&gt; a[i].y; for(int i = 1 ; i &lt;= n ; ++ i) &#123; int u = a[i].x + 1; int v = sum(u); update(u,1); ans[v] ++; &#125; for(int i = 0 ; i &lt; n ; ++ i) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;&#125; 再看一题： 二维偏序模板题 这是一道简单的二维偏序题，我们仍然可以用树状数组简单的A掉这一题，注意的是我们在查询时因为$i_x &lt;= j_x,i_y &lt;= i_y$所以我们查询时我们需将查询的值加一在查询。但我们的目标不是用树状数组解决它，我们要用CDQ分治解决它。 就和基本解题思路一样，我们可以考虑先按照关键字$x$排序，然后因为$x$已经有序，所以我们只需要处理出满足$i_y &lt;= j_y(i &lt; j)$的顺序对个数就可以了(我们机房某神犇告诉我其实也可以用总共的对数也就是$n * (n - 1) / 2$减去逆序对个数来求解) 具体的代码： 顺序对： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 100005#define int long long//注意一定要开long long不然只有30分int n,cnt,t[maxn &lt;&lt; 1],ans;struct node&#123; int x;int y;&#125;a[maxn];bool cmp(node q,node p)&#123; if(q.x != p.x)return q.x &lt; p.x; else return q.y &lt; p.y;&#125;void mergesort(int l,int r)&#123; if(l == r)return; int mid = l + r &gt;&gt; 1; mergesort(l,mid);mergesort(mid + 1,r); int p = l,q = mid + 1,cnt = l;/* cout &lt;&lt; "[" &lt;&lt; l &lt;&lt; "," &lt;&lt; r &lt;&lt; "]" &lt;&lt; ": "&lt;&lt; endl; for(int i = l ; i &lt;= r ; ++ i) cout &lt;&lt; a[i].y &lt;&lt; " "; cout &lt;&lt; endl &lt;&lt; "ans: " &lt;&lt; endl;*/ while(p &lt;= mid and q &lt;= r)&#123; if(a[p].y &lt;= a[q].y)t[cnt++] = a[p++].y,ans += r - q + 1; else t[cnt++] = a[q++].y; &#125;// cout &lt;&lt; ans &lt;&lt; endl; while(p &lt;= mid)t[cnt++] = a[p++].y; while(q &lt;= r)t[cnt++] = a[q++].y; for(int i = l ; i &lt;= r ; ++ i)a[i].y = t[i];&#125;signed main()//相当与int main()&#123; cin &gt;&gt; n; for(int i = 1 ; i &lt;= n ; ++ i) cin &gt;&gt; a[i].x &gt;&gt; a[i].y; sort(a + 1,a + n + 1,cmp);/* for(int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; a[i].y &lt;&lt; " "; cout &lt;&lt; endl;*/ mergesort(1,n); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 总对数-逆序对 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 100005#define int long longint n,cnt,t[maxn &lt;&lt; 1],ans;struct node&#123; int x;int y;&#125;a[maxn];bool cmp(node q,node p)&#123; if(q.x != p.x)return q.x &lt; p.x; else return q.y &lt; p.y;&#125;void mergesort(int l,int r)&#123; if(l == r)return; int mid = l + r &gt;&gt; 1; mergesort(l,mid);mergesort(mid + 1,r); int p = l,q = mid + 1,cnt = l; while(p &lt;= mid and q &lt;= r)&#123; if(a[p].y &lt;= a[q].y)t[cnt++] = a[p++].y; else&#123; t[cnt++] = a[q++].y; ans += mid - p + 1; &#125; &#125; while(p &lt;= mid)t[cnt++] = a[p++].y; while(q &lt;= r)t[cnt++] = a[q++].y; for(int i = l ; i &lt;= r ; ++ i)a[i].y = t[i];&#125;signed main()&#123; cin &gt;&gt; n; for(int i = 1 ; i &lt;= n ; ++ i) cin &gt;&gt; a[i].x &gt;&gt; a[i].y; sort(a + 1,a + n + 1,cmp); /*for(int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; a[i].y &lt;&lt; " "; cout &lt;&lt; endl;*/ mergesort(1,n); cout &lt;&lt; n * (n - 1) / 2 - ans &lt;&lt; endl; return 0;&#125; 其中顺(逆)序对都是用归并排序实现的。 写了这么多，终于要步入正题了。 正题由于本人太弱，目前只会三维的CDQ分治求解，高维要用CDQ套CDQ 三维偏序(陌上花开)沿用二维偏序的代码和基本的解题思想，我们不难得出先sort出一维，再用CDQ分治求解二维，三维交给树状数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;int n,k,ans[maxn],tree[maxn * 2];struct flower&#123; int x;int y;int z;int num;int ans;&#125;a[maxn],b[maxn];bool cmp(flower &amp;q,flower &amp;p)&#123; if(q.x != p.x)return q.x &lt; p.x; if(q.y != p.y)return q.y &lt; p.y; return q.z &lt; p.z;&#125;bool same(flower &amp;q,flower &amp;p)&#123; return (q.x == p.x and q.y == p.y and q.z == p.z);&#125;void add(int x,int y)&#123; for(int i = x ; i &lt;= k ; i += (i &amp; (-i)))tree[i] += y; return;&#125;int query(int x)&#123; int res = 0; for(int i = x ; i ; i -= (i &amp; (-i)))res += tree[i]; return res;&#125;void cdq(int l,int r)&#123; if(l &gt;= r)return; int mid = l + r &gt;&gt; 1; cdq(l,mid);cdq(mid + 1,r); for(int i = l,j = l,p = mid + 1;i &lt;= r ; ++ i)&#123; if(j &lt;= mid and (p &gt; r or a[j].y &lt;= a[p].y))b[i] = a[j++]; else b[i] = a[p++]; &#125; for(int i = l ; i &lt;= r ; ++ i)&#123; a[i] = b[i]; if(a[i].num &lt;= mid)add(a[i].z,1); else a[i].ans += query(a[i].z); &#125; for(int i = l ; i &lt;= r ; ++ i)if(a[i].num &lt;= mid)add(a[i].z,-1); return;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for(int i = 1 ; i &lt;= n ; ++ i) cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].z; sort(a + 1,a + 1 + n,cmp); flower t;int cnt = 1; for(int i = n ; i &gt;= 1 ; -- i)&#123; if(same(t,a[i]))&#123; a[i].ans += cnt; ++ cnt; &#125; else &#123; t = a[i]; cnt = 1; &#125; &#125; for(int i = 1 ; i &lt;= n ; ++ i)a[i].num = i; cdq(1,n); for(int i = 1 ; i &lt;= n ; ++ i)ans[a[i].ans]++; for(int i = 0 ; i &lt; n ; ++ i)cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;&#125; 终于写完了，呜呜呜呜~~数学立体几何好难啊，要是CDQ分治能解立体几何就好了。 同时以此文膜拜一下学姐。 各位晚安qwq。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基环树学习理解]]></title>
    <url>%2F2019%2F01%2F12%2F%E5%9F%BA%E7%8E%AF%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[基环树学习理解定义基环树是一种特殊的图，我们知道树是由$N$个点，$N - 1$条边组成的，那么我们在树上任意两点之间加上一条边都会产生一个环，我们把这种$N$个点，$N$条边组成的联通无向图称为基环树。如果不保证联通，也可能是基环树森林，注意基环树森林中每个点都必须有一条边连接起来。如果存在独立的点的话，那么很可能其中的一个联通子图中存在两个环，而基环树去要求有且只有一个环。 一般的题型基环树的直径(树上两点之间的距离中的最大值)，基环树上的动态规划，基环树两点之间的距离。 一般解题思路基环树的最大特征就是有且只有一个环。所以我们解题(接下来以求基环树的直径为例)时，一般从环入手，先找到环。其中找环过程可以用$BFS$的拓扑排序或$DFS$遍历。然后我们可以考虑从环上每个节点出发，在不经过环上其他点的情况下处理出这棵子树的最长链以及叶子节点到根节点的最长距离。然后我们知道基环树的直径只可能有两种情况： 1.树上最长链出现在子树中 2.环上两棵子树中的叶子节点到另一棵子树的叶子节点经过环 所以我们只需在环上在进行一遍$dp$把环上的边考虑进来就可以了。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性方程组]]></title>
    <url>%2F2018%2F12%2F22%2F%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题面：模板高斯消元加强版。 给你$n$个方程其中含有$n$个未知数，判段方程是否有唯一解。若方程有无数个解，输出$0$，若方程无解，输出$-1$，若方程有唯一解，输出该解。 输入格式： 第一行：未知数的个数。以下$n$行$n+1$列：分别表示每一格方程的系数及方程右边的值。 输出格式： 如果方程组无实数解输出$-1$； 如果有无穷多实数解，输出$0$； 如果有唯一解，则输出解（小数点后保留两位小数）。 输入输出样例输入样例#1： 输出样例#1： 3 x1=1.002 -1 1 1 x2=04 1 -1 5 x3=-1.001 1 1 0 思路这题和高斯消元模板题一样，只是多了一个判定方程是无穷解还是无解。 无解情况是高斯消元完后方程左边的系数全为0，但方程右边不为0。 无穷解的情况是：高斯消元完后存在某一行或多行全为0。 唯一解就是不满足上述的情况。 但这题一个比较麻烦的小细节是： 在洛谷P3389中的高斯消元我们是在消元的过程中发现当前行的当前要消的列的系数为0就返回false。很遗憾在这一题行不通。(什么？你问我为什么，请看一下hack数据) Input(hack)30 0 1 20 0 1 10 0 0 0 Output(hack)-1 再发一组hack数据吧。 Input:34 2 3 14 1 2 35 2 3 3 Output:x1=2.00x2=1.00x3=-3.00 注：因为本题数据太水，你可能也过了，但我们追求的是正确的解法和能力的提高不是吗？ 同时这一题貌似还卡精度。 所以我们可以这样处理： 遇到当前要消去的列(最大绝对值)的系数为0，就跳过，直到找到一个不为零的项为止。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 55;const double eps = 1e-8;int n;double a[maxn][maxn],del;int main()&#123; cin &gt;&gt; n; for(int i = 1 ; i &lt;= n ; ++ i) for(int j = 1 ; j &lt;= n + 1; ++ j) cin &gt;&gt; a[i][j]; for(int i = 1 ,c = 1; i &lt;= n ; ++ i)//枚举列，c为行 &#123; int k = c; for(int j = c + 1 ; j &lt;= n ; ++ j)if(fabs(a[j][i]) &gt; fabs(a[k][i]))k = j;//枚举列（交换用） if(fabs(del = a[k][i]) &lt; eps)continue;// 如果当前列为0，说明后面的所有都为0，接着枚举该行// &#123;// many = 1;// continue;// &#125; for(int j = i ; j &lt;= n + 1 ; ++ j)swap(a[c][j],a[k][j]); for(int j = i ; j &lt;= n + 1 ; ++ j)a[c][j] /= del; for(int k = 1 ; k &lt;= n ; ++ k) if(k != c)&#123; del = a[k][i]; for(int j = i ; j &lt;= n + 1 ; ++ j)a[k][j] -= a[c][j] * del; &#125; ++ c; &#125;/* for(int i = 1 ; i &lt;= n ; ++ i) &#123; for(int j = 1 ; j &lt;= n + 1; ++ j) cout &lt;&lt; a[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125;*/ bool many = 0; for(int i = 1 ; i &lt;= n ; ++ i) &#123; bool noanw = 0; for(int j = 1 ; j &lt;= n ; ++ j) if(a[i][j])noanw = 1; if(!noanw and a[i][n + 1])&#123; cout &lt;&lt; -1 &lt;&lt; endl; return 0; &#125; if(!noanw and !a[i][n + 1]) many = 1; &#125; if(many)&#123; cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; for(int i = 1 ; i &lt;= n ; ++ i) printf("x%d=%.2lf\n",i,a[i][n + 1]);&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[球形空间产生器]]></title>
    <url>%2F2018%2F12%2F22%2F%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题面 有一个球形空间产生器能够在 $n$ 维空间中产生一个坚硬的球体。现在，你被困在了这个 $n$ 维球体中，你只知道球面上 $n+1$ 个点的坐标，你需要以最快的速度确定这个 $n$ 维球体的球心坐标，以便于摧毁这个球形空间产生器。 数据范围： $1&lt;=N&lt;=10$ 思路首先球心到达每个点的距离是相等的，我们可以依据这个来列方程，然后用高斯消元求解。 数学以二维为例： 设中心坐标为$(x_0,y_0)$半径为$r$,则可以列出方程： $(x_1 - x_0)^2 + (y_1 - y_0)^2 = r^2$ ① $(x_2 - x_0)^2 + (y_2 - y_0)^2 = r^2$ ② ①$-$②得： $(x_1 - x_0)^2 + (y_1 - y_0)^2 - (x_2 - x_0)^2 - (y_2 - y_0)^2 = 0$ 化简得： $(x_1 + x_2 - 2x_0)(x_1 - x_2) + (y_1 + y_2 - 2y_0)(y_1 - y_2) = 0$ $x_1^2 - x_2^2 + y_1^2 - y_2^2 - 2(x_1 - x_2)x_0 - 2(y_1 - y_2)y_0 = 0$ 其中$x_1,x_2,y_1,y_2$是已知的。我们可以将后两项移项，得到高斯消元的基本式。 然后我们就可以愉快地上模板了。 [代码]123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 15;const int eps = 1e-8;int n;double a[maxn][maxn],Matrix[maxn][maxn],del;bool guass()&#123; for(int i = 1 ; i &lt;= n ; ++ i) &#123; int k = i; for(int j = i + 1 ; j &lt;= n ; ++ j)if(fabs(Matrix[j][i] &gt; fabs(Matrix[k][i])))k = j; if(fabs(del = Matrix[k][i]) &lt; eps)return 0; //swap(Matrix[i], Matrix[k]); for(int j = i ; j &lt;= n + 1 ; ++ j)swap(Matrix[i][j],Matrix[k][j]); for(int j = i ; j &lt;= n + 1 ; ++ j)Matrix[i][j] /= del; for(int k = 1 ; k &lt;= n ; ++ k) if(k != i)&#123; del = Matrix[k][i]; for(int j = i ; j &lt;= n + 1 ; ++ j)Matrix[k][j] -= del * Matrix[i][j]; &#125; &#125; return 1;&#125;int main()&#123;// ios::sync_with_stdio(0); cin &gt;&gt; n; for(int i = 1 ; i &lt;= n + 1 ; ++ i) for(int j = 1 ; j &lt;= n ; ++ j) cin &gt;&gt; a[i][j]; for(int i = 1 ; i &lt;= n ; ++ i) &#123; for(int k = 1 ; k &lt;= n ; ++ k) &#123; Matrix[i][k] = 2 * (a[i][k] - a[i + 1][k]); Matrix[i][n + 1] += (a[i][k] * a[i][k] - a[i + 1][k] * a[i + 1][k]); &#125; // Matrix[i][n + 1] = res; &#125; guass(); for(int i = 1 ; i &lt;= n ; ++ i) printf("%.3lf ",Matrix[i][n + 1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷]榨取kkksc03]]></title>
    <url>%2F2018%2F12%2F18%2F%E6%B4%9B%E8%B0%B7-%E6%A6%A8%E5%8F%96kkksc03%2F</url>
    <content type="text"><![CDATA[题面给你一定的时间和背包容量，现在有$n$个物品，选择它们，需要一定的时间还需耗费你的一定背包容量。求最多能选几个物品。 先分析一下思路：如果只有一件费用，那么就可以直接上贪心了。将费用$sort$一遍，然后就直接一样一样的选。可是现在是二维的费用了，也就是说它有两项费用需均衡同时考虑。这就是一道明显的二维费用的背包问题了。 首先我们枚举物品用一层循环枚举容量，然后再用一层循环枚举时间；我们就考虑一下，我们是选当前这件物品，还是不选。如果选我们还剩多少的背包容量和时间，然后它的总收益就是剩下的能选的最大数$+1$，在和当前已知的用同样的时间和背包容量能选的最大值比较，取最大值，就可以了。 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,t,m1[105],t1[105],f[205][205];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m&gt;&gt;t; for(int i = 1; i &lt;= n; ++ i) cin&gt;&gt;m1[i]&gt;&gt;t1[i]; for(int i = 1; i &lt;= n; ++ i) for(int j = m; j &gt;= m1[i]; -- j) for(int k = t; k &gt;= t1[i]; -- k) f[j][k] = max(f[j][k],f[j - m1[i]][k - t1[i]]+1); cout&lt;&lt;f[m][t]; return 0;&#125; 附加：如果你实在不会打动态规划，那么你也可以用记忆化搜索，这两种方法本质都是一样的) 不过建议你还是学习一下动态规划吧，毕竟动规只是思路比较难，但动规实现还是很好的。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划,动规,dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板]treap]]></title>
    <url>%2F2018%2F12%2F17%2F%E6%A8%A1%E6%9D%BF-treap%2F</url>
    <content type="text"><![CDATA[treap模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 1 &lt;&lt; 30;const int maxn = 1e7 + 10;int n,tot,root;struct treap&#123; int l,r,val,dat;//左子树编号，右子树编号，节点关键码，权值； int size,cnt;//子树大小，副本个数（均包括自己）；&#125;a[maxn];//增加新节点int New(int val)&#123; a[++tot].val = val; a[tot].dat = rand();//随机分配一个权值 a[tot].cnt = a[tot].size = 1;//副本和子树大小为1； return tot;//返回当前节点的编号；&#125;//重新计算子树大小；void Update(int p)&#123; a[p].size = a[a[p].l].size + a[a[p].r].size + a[p].cnt; //子树大小等于左右子树大小加副本数；&#125;//建树：void build()&#123; New(-INF),New(INF);//插入正无穷和负无穷 root = 1,a[1].r = 2;//根据BST的基础定义,左小,右大，根中间； Update(root);&#125;//查询x数的排名int GetRankByVal(int p,int val)&#123; if(p == 0)return 0;//如果没有了就返回0； if(val == a[p].val)return a[a[p].l].size; //如果查到了，就返回其左子树的大小 if(val &lt; a[p].val)return GetRankByVal(a[p].l,val); return GetRankByVal(a[p].r,val) + a[a[p].l].size + a[p].cnt;&#125;int GetValByRank(int p,int rank)&#123; if(p == 0)return INF; //cout &lt;&lt; rank &lt;&lt; endl; //cout &lt;&lt; a[p].val &lt;&lt; endl; //cout &lt;&lt; p &lt;&lt; ": " &lt;&lt; a[p].size &lt;&lt; " l :"&lt;&lt; a[a[p].l].size &lt;&lt; endl; if(a[a[p].l].size &gt;= rank)return GetValByRank(a[p].l,rank); if(a[a[p].l].size + a[p].cnt &gt;= rank)return a[p].val; return GetValByRank(a[p].r,rank - a[a[p].l].size - a[p].cnt);&#125;//右旋（压缩包？？）void zip(int &amp;p)&#123; int q = a[p].l;//将当前节点的左节点记录下来； a[p].l = a[q].r,a[q].r = p,p = q;//当前节点的左节点变为其原左节点的右节点，因为左子树的任何一棵子树都是比当前节点小的；当前节点的右节点不变；//原左节点的左子树不变，右子树变为当前节点，即它原先的父节点；//在将当前的节点变为原左节点，因为p是个引用，so调用的p会变为q，因为此时q为父节点了； Update(a[p].r),Update(p);&#125;//左旋void zap(int &amp;p)&#123; int q = a[p].r;//将当前节点的右节点记录下来； a[p].r = a[q].l , a[q].l = p , p = q;//当前节点的右节点比当前节点及其左子树大，所以将当前节点变为其原节点的左子树，同时将原右节点的左子树变为当前节点的左子树 Update(a[p].l),Update(p);&#125;void Insert(int &amp;p,int val)&#123; //如果没有该节点； if(p == 0)&#123; p = New(val);//注意p是引用！！！这很重要，p会涉及旋转，所以请读者好好理解； return; &#125; //如果有该节点； if(val == a[p].val)&#123; a[p].cnt++,Update(p);//副本加1；重新计算子树大小； return; &#125; //如果小了； //根据定义，往左走； if(val &lt; a[p].val)&#123; Insert(a[p].l,val); if(a[p].dat &lt; a[a[p].l].dat)zip(p); //重点，如果加入的节点在左，为了使树更加平衡（因为此时左子树may大于右子树），我们需要将当前节点变为当前节点的左节点的右子树；这就是旋转操作；这是为了防止树退化成链的情况。 &#125; else &#123; Insert(a[p].r,val); if(a[p].dat &lt; a[a[p].r].dat)zap(p);//同理; &#125; Update(p);//回溯时重新计算经过的节点的size；&#125;//找前驱int GetPre(int val)&#123; int ans = 1;//a[1].val == -INF int p = root; while(p) &#123; if(val == a[p].val)&#123; if(a[p].l &gt; 0)&#123; p = a[p].l; while(a[p].r &gt; 0)p = a[p].r; ans = p; &#125; break; &#125; if(a[p].val &lt; val and a[p].val &gt; a[ans].val)ans = p; p = val &lt; a[p].val ? a[p].l : a[p].r; &#125; return a[ans].val;&#125;//后继同理int GetNext(int val)&#123; int ans = 2;//a[2].val = INF; int p = root; while(p) &#123; if(val == a[p].val) &#123; if(a[p].r &gt; 0) &#123; p = a[p].r; while(a[p].l &gt; 0)p = a[p].l; ans = p; &#125; break; &#125; if(a[p].val &gt; val and a[p].val &lt; a[ans].val)ans = p; p = val &lt; a[p].val ? a[p].l : a[p].r; &#125; return a[ans].val;&#125;//删除操作void Remove(int &amp;p,int val)&#123; if(p == 0)return; if(val == a[p].val)//查到了val； &#123; if(a[p].cnt &gt; 1)&#123; a[p].cnt--,Update(p); return; &#125; if(a[p].l or a[p].r)&#123;//不是叶子节点，就将当前节点向下旋转，这是为了不让子树受到不必要的影响（可能删去后接上时不满足BST的基本结构）； if(!a[p].r or a[a[p].l].dat &gt; a[a[p].r].dat) //如果右子树不为空，或左子树的权值比右子树大； zip(p),Remove(a[p].r,val);//右旋； else zap(p),Remove(a[p].l,val);//反之，左旋； Update(p); &#125; else p = 0; return; &#125; val &lt; a[p].val ? Remove(a[p].l,val) : Remove(a[p].r,val); //同插入； Update(p);//计算子树大小；&#125;int main()&#123; srand(time(NULL)); ios::sync_with_stdio(0); build(); cin &gt;&gt; n; int kmp = 2; while(n--)&#123; int opt,x; cin &gt;&gt; opt &gt;&gt; x; if(opt == 1) &#123; kmp ++; Insert(root,x); &#125; if(opt == 2)Remove(root,x); if(opt == 3)cout &lt;&lt; GetRankByVal(root,x) &lt;&lt; endl; if(opt == 4)cout &lt;&lt; GetValByRank(root,x+1) &lt;&lt; endl; if(opt == 5)cout &lt;&lt; GetPre(x) &lt;&lt; endl; if(opt == 6)cout &lt;&lt; GetNext(x) &lt;&lt; endl;// for(int i = 1 ; i &lt;= kmp ; ++ i)// cout &lt;&lt; a[i].val &lt;&lt; "," &lt;&lt; a[i].l &lt;&lt; "," &lt;&lt; a[i].r &lt;&lt; endl; &#125; return 0;&#125;//同时感谢海波大佬在我旁边给我的帮助。 可能我后面有些没有写注释了，恳请原谅，最近实在是太忙了。 感谢提供帮助的海波大佬($\color{skyblue}Na2S2O3$)]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP反省与分析]]></title>
    <url>%2F2018%2F12%2F17%2FNOIP%E5%8F%8D%E7%9C%81%E4%B8%8E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[$\color{red}{NOIP2018}$反省与分析关于本次$\color{red}{NOIP}$的一点总结先总结一下自己这次$\color{red}{NOIP}$做的好的一点吧。 这次$\color{red}{NOIP}$是抱着平常心态去考的，虽然其中出现了很多的障碍，但是心态保持的很好，没有出现什么心态爆炸。可以说这是我相对发挥不错的一次了。 但是从中也体现了我的很多不足，最重要的就是知识储备问题，所以这次考这个分数我一点都不冤枉，当时考前也是抱着侥幸的心理，认为联赛不会考什么什么知识点，学的也是一塌糊涂，很多知识点都是屈老师强调过的，比如说$\color{blue}dp$(钻进地洞)，考前一知半解，考场上自然就打不出来。感谢这次考试，让我看到了自己的不足。 今后我要踏踏实实的学习$OI$，认认真真的学习每一个知识点。为下次考试做好准备（当然文化也不能落下）]]></content>
      <categories>
        <category>心得</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NOIP游记]]></title>
    <url>%2F2018%2F12%2F15%2FNOIP%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[$\color{Blue}{NOIP}$退役记关于本次的$NOIP$心里都是悔恨。。。。。（文件名都打错了）； 考前 蒟蒻的我是最后一批停课的（果然还是太菜了），但还是因此逃过了期中考试然后接下来就是各种各样的集训，每天就是上午写题，下午改题，晚上接着考。感觉自己经历了绝望，看着自己不忍入目的分数与大佬的神仙成绩，感觉$NOIP$凉了。 $day0:$ 考前看了看基础算法的模板，复习复习（然而貌似并没有什么用）晚上睡得很香呢 ^ _ ^ $day1:$ 首先浪费了半个小时调配置。 调完后猛然发现无法解压文件（好方）最后找监考老师用他的U盘重新拷了一份试题才能解压。（不祥的预感） 第一题这这是什么$???$ $n^2$不能过？集中生智的把所有数据看了一遍找到了规律（好像是类似差分的一个东西）。（耗了我$20$分钟……最后出考场发现是原题……石化了） 第二题理解错了题意，花了半个小时改，发现错了（以为是小凯的疑惑，发现过不了大样例心情简单 才怪）。 于是开始重码代码，码了一个玄学的筛法(本来想打完全背包(有个小细节不会处理))。后来测试还过了。（开心） 第三题看了后感觉可能是树形dp+二分答案（然而树形$dp$不会打）（$qwq$） 第一天总体感觉还好吧。除了最后一题的骗分外，其他题的的总体发挥还是令我蛮满意的。 $day2$ 第一题最开始觉得还蛮简单，以为一通暴搜加贪心就可以了，结果看了数据后发现不对劲$(m = n - 1)???$那不是树了吗？在往下滑发现$(m = n)$，舒了口气。以为上面的树的情况是部分分。结果考完后别人告诉我是基树环。………… 第二题看了后以为是数论（事实上在标程出来之前都没推出来……）花了我考场珍贵的两小时在上面，结果不仅没推出来，文件名也没检查，然后你懂得。。 没有第三题了………… 第二天是真的炸了，主要还是自己好多知识的储备还不够，回去后要好好反省这次考试了。 总体的情况还算正常。感觉自己最近有点过多关注这次考试成绩了（能不关心吗??） 总之已经考完了（考后当然该大颓一波）考完后看了看柯南，震惊与安室透的飙车技术，看到最后突然想起这次$NOIP$提高组考凉了…… 写完这个后我就不再谈这次考试成绩了。分析与反省比成绩单上的数字更重要，好好学习才是接下来我该做的。想到还有一堆作业等着我 $\color{blue}{NOIP}$反省与总结]]></content>
      <categories>
        <category>心得</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[尚未完成的知识点]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%9C%AA%E5%AE%8C%E6%88%90%2F</url>
    <content type="text"><![CDATA[$HLPP$学习，$fhq-treap$学习，$splay$学习，FFT学习，莫队，主席树，可持久化trie树，虚树，莫比乌斯反演 费用流练习，分块练习， 概率期望，费用流(Dinic版)，CDQ分治，基环树 $treap$巩固，树型$dp$巩固，数位$dp$巩固，博弈论巩固，高斯消元巩固，KMP巩固，$tarjan$巩固，负环与差分约束巩固，割点和桥巩固，$RMQ$巩固，同余方程巩固，组合数学巩固，$Dinic$巩固，单调栈/队列练习，树链剖分，LCT 复习： 区间$dp$，状压$dp%$，$Trie$字典树，并查集，线段树，树状数组，矩阵乘法，倍增，图的遍历，二分图，$hash$ 慢慢填坑吧。 加油，日积月累的你一定能成功。]]></content>
      <tags>
        <tag>学习备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷]过河]]></title>
    <url>%2F2018%2F12%2F13%2F%E6%B4%9B%E8%B0%B7-%E8%BF%87%E6%B2%B3%2F</url>
    <content type="text"><![CDATA[题面传送门： $Luogu$基本的思路很简单： 第一眼看这题的同学应该首先立即就会想到动规吧。（显而易见） 因为它满足无后效性。 当前的每一个状态都可以由之前的状态转移过来。 当前的决策对之后都不会产生影响。 $\color{blue}{But}$动态规划最重要的就是状态转移方程。 恩，经过一段思考我们不难得出以下几条结论： 当前的点$i$只与它前$i-j$个点有关($s\leq j\leq t$) 如果当前的点是石头那么就是所有到达该点的位置所需踩的最少石头数加$1$ 经过上述的分析我们就可以得出我们的状态转移方程了： 该点为石头：$dp[i] = min(dp[i],dp[i-j] +1)(s\leq j\leq t)$ 该点不为石头：$dp[i] = min(dp[i],dp[i-j])(s\leq j\leq t)$ 分析到这好像差不多了。 等等！ 当我们猛然看到数据范围时就会发现这题没有这么简单：$L\leq 10^9$ 这么大的数据范围用数组存肯定存不下。 但是我们却惊奇发现石头数很小。 怎么办呢？先让我们来看看这张图： 其中$[S_i,T_i]$就是青蛙可以到的区间。可以发现当$\color{Red}{\textbf{s &lt; t}}$时，$s$和$t$一定会重合（当距离为$lcm(s,t)$即$s$，$t$的最小公倍数时）而这以后的每个点都可以到达，所以我们只需将每两个石头超过 $s\times t$ 的距离缩成$s \times t$就可以了当然如果你有疑虑的话也可以开大一点。 当$s = t$时我们只需枚举每个石头的坐标是否为$s$的倍数即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 150;const int maxl = 300 * 105;//其实开90 * 105就可以了；int L,s,t,m,stone[maxn],a[maxn],dp[maxl],base;//stone就是石头的初始位置；a为我们将石头初始化后的石头位置；bool vis[maxl];//标记一下坐标上的该点是否为石头；int main()&#123; ios::sync_with_stdio(0);// 关掉同步，加快cin的速度 cin &gt;&gt; L; cin &gt;&gt; s &gt;&gt; t &gt;&gt; m; base = s * t; for(int i = 1 ; i &lt;= m ; ++ i) cin &gt;&gt; stone[i]; sort(stone + 1,stone + 1 + m);// 判段s == t的情况 if(s == t)&#123; int cnt =0; for(int i = 1 ; i &lt;= m ; ++ i) if(stone[i] % s == 0)cnt++; cout &lt;&lt; cnt &lt;&lt; endl; return 0; &#125; for(int i = 1 ; i &lt;= m ; ++ i) &#123;// 离散化过程 int d = stone[i] - stone[i - 1]; if(d &gt;= base)d = base; a[i] = a[i - 1] + d; vis[a[i]] = 1; &#125; L = a[m] + base;// 将L变成最后一个石头的位置+s*t// 如果L - a[m] &gt;= s * t就缩成s * t// 如果L - a[m] &lt;= s * t就加上一个数使得它等于这个距离因为青蛙可能跳出独木桥 memset(dp,0x7f,sizeof(dp)); dp[0] = 0;// 初始化到原点寻最少踩0个石头 for(int i = 1 ; i &lt;= L ; ++ i) for(int j = s ; j &lt;= t ; ++ j) &#123; if(i - j &gt;= 0) &#123; if(vis[i])dp[i] = min(dp[i - j] + 1,dp[i]); else dp[i] = min(dp[i - j],dp[i]); &#125; &#125; int ans = maxn;// 给答案赋一个较大的初值 for(int i = a[m] ; i &lt;= L ; ++ i) ans = min(ans,dp[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划,动规,dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F13%2FHello-World%2F</url>
    <content type="text"><![CDATA[Welcome to my blog!1234#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl; &#125; 感谢$\color{red}{zqr}$大佬和$\color{skyblue}{Na2S2O3}$的帮助，才使得我顺利搭建起了这个博客]]></content>
  </entry>
</search>
